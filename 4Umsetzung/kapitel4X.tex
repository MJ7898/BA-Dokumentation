\subsection{Visualisierungs-Phase} 
Nach vollständiger Beendigung der Scan-Phase ging es in der Entwicklung weiter mit der Visualisierungs-Phase. Die zuvor gespeicherten Objekte und 
deren Informationen werden dabei abgerufen und können jederzeit erneut visualisiert und im Raum platziert werden. Die folgende Darlegung der 
Frontend-Entwicklung der Visualisierungs-Phase gibt Aufschluss über die Benutzeroberfläche dieser Phase und deren Aufbau. %Die Ausführung des Frontends und deren bildliche 
%Darstellung dient dazu, das anschließende Backend nachvollziehen zu können. Abschließend werden die Aspekte des Frontends aufgegriffen und anhand der Backend-Implementierung 
%mit deren Funktionen verknüpft. 

\subsubsection{FrontEnd}
Bei der Visualisierungs-Phase gibt es prinzipiell eine Benutzeroberfläche, die diesen Use Case ausmacht. Unter eigentlicher Anwendung dieser Phase und 
deren \acs{GUI} befinden sich darüber hinaus weitere Benutzeroberflächen, die bereits in der Scan-Phase schon erläutert wurden. Darunter zum Beispiel 
die in Abbildung (\ref{pic:image_tracking}) zu entnehmende Markererkennungs-\acs{UI}, die ebenso Bestandteil der Visualisierungs-Phase ist. 
\\ 
Die primäre \acs{GUI} ist ähnlich zu der Benutzeroberfläche der Scan-Phase aufgebaut. Ein Fragment das sich über den ganzen Bildschirm erstreckt, repräsentiert das 
Livebild der Kamera. Dadurch können die bereits in der Scan-Phase erstellten Objekte erneut angezeigt werden. Dadurch ist eine überschaubare und leicht zu verstehende 
Oberfläche gegeben. Des Weiteren befinden 
sich auf dieser Oberfläche zwei Buttons, zum einen zur Navigation, um auf das Startmenü zu gelangen, und zum anderen, um die Objekte von der Datenbank 
abzugreifen, rendern und auf dem Bildschirm anzeigen zu lassen. Diese befinden sich jeweils in der linken und rechten unteren Ecke des Bildschirms, wie 
der Abbildung \ref{pic:visual} zu entnehmen ist. 
\\ 
Da diese \acs{UI} nur als Ansicht der zu visualisierenden Objekte gedacht ist, stehen dem Nutzer für die Interaktionen nur die Objekte, die als Overlay 
über das Kamerabild gelegt werden, zur Verfügung. Die Nutzeraktionen beschränken sich lediglich auf den Gebrauch der zuvor genannten Buttons und die dynamisch erzeugten 
Schaltflächen der Objekte, um über diese zusätzliche Informationen zu erhalten. 
\begin{figure}[hbt!]
    \centering
    \includegraphics[width=7cm,height=7cm,keepaspectratio]{4Umsetzung/Bilder/visual-phase.jpg}
    \caption{Visualisierungs-Phase der Applikation}
    \label{pic:visual}
\end{figure} 
\\ 
Mit der soeben erläuterten Benutzeroberfläche geht folgender Programmablauf einher. Mit der gewonnenen Kenntnis des Ablaufs kann sich die 
Implementierung des Backends daran stützen. 
\begin{figure}[hbt!]
    \centering
    \includegraphics[width=15cm,height=15cm,keepaspectratio]{4Umsetzung/Bilder/visualPAP.png}
    \caption{Programmablaufplan der Visualisierungs-Phase}
    \label{pic:startmenu}
\end{figure}
%\pagebreak
\\
\linebreak
Auf Grundlage der Benutzeroberflächen erfolgt die Beschreibung der Backend-Implementierung und Einblicke in die Programmierung der Visualisierungs-Phase.

\subsubsection{BackEnd}
Nachdem das Problem der variablen Startposition in der Implementierung der Scan-Phase umgangen wurde, konnte die Visualisierungs-Phase entwickelt werden. 
\\ 
\linebreak
Wählt der Anwender auf der Startmenü-\acs{UI} (\ref{pic:startmenu}) den Button „Virtual-Phase“, wird eine Anmerkung getätigt, indem der Nutzer darüber in 
Kenntnis gesetzt wird, dass er zu Beginn die Scan-Phase durchgeführt haben muss, bevor die Visualisierungs-Phase gestartet werden kann. Diesen Vermerk kann der 
Benutzer ignorieren, wenn dieser weiß, dass ein Scan durchgeführt wurde, oder er akzeptiert den Hinweis und wird auf die dementsprechende Funktion weitergeleitet. 
Der Nutzer wird dadurch davor bewahrt, eine Funktion starten zu wollen, die ohne Inhalt keine Änderungen aufzeigt.
\\ 
Danach wird der Nutzer aufgefordert, den initialen Marker (\ref{pic:initialMarker}) einzuscannen, um die ursprüngliche Position, bzw. die Markierung festzuhalten. 
Damit kann der weitere Programmablauf folgen, indem die \acs{GUI} der Visualisierungs-Phase (\ref{pic:visual}) angezeigt und eine neue Session zur 
Objektplatzierung gestartet wird. 
\\
Über eine ViewModel-Komponente werden die Objekte aus der Datenbank abgefragt und in einer Liste gespeichert, um diese zu einem späteren Zeitpunkt zur Platzierung der 
Objekte verwenden zu können.
\\
Ist der Marker erkannt worden, wird mithilfe des Buttons, der sich im rechten unteren Eck der Benutzeroberfläche (\ref{pic:visual}) befindet, die Methode zur 
Datenabfrage, Erzeugung und Platzierung der Objekte gestartet. Dabei wird über den Button-Klick eine Funktion aufgerufen, die die Liste der Objekte anspricht und 
die jeweils darin enthaltenen Objekte nacheinander generiert. Nach Betätigen des Buttons ist dieser auf der \acs{UI} nicht mehr aufzufinden, um einer weiteren 
Platzierung aller Objekte vorzubeugen. Die von dem ViewModel gegebene Liste wird, abhängig von deren Länge, iterativ abgearbeitet und die Objekte 
nacheinander angelegt. Dies erfolgt über eine „for“-Schleife, welche abhängig von dem Ursprungspunkt, dem Marker „objectMarkerCenter“, die Position des 
aktuellen Objekts „obj“ an der Stelle „i“ in der Liste neu errechnet und darstellt.
\\ 
%\linebreak
\begin{lstlisting}[language=C,
    frame=lines,           % Ein Rahmen um den Code (single for box, lines for top and bottom)
    xleftmargin=\parindent,  % Rahmen link von den Zahlen
    style=algoBericht,
    label={code:listOfObjects},
    captionpos=b,           % Caption unter den Code setzen
caption={Abfolge der Objekte in der Liste}]
... 
for (int i = 1; i < listOfObj.size(); i++){
    obj = listOfObj.get(i);
    if(!obj.getName().equals("origin")) {
        calculateObjectPosition(obj, i, objectMarkerCenter);
    }
}
\end{lstlisting}
Mit der gegebenen „calculateObjectPosition“ wird dann die Distanz vom Ursprungsmarker zu dem Objekt addiert, um 
die Positionen und Distanzen der einzelnen Objekte der Scan-Phase exakt wiederzugeben. Ist die Addition zu einem Objekt durchgeführt, repräsentiert diese 
Berechnung unabhängig von der Startposition des Anwenders die neue Position, an der das Objekt platziert werden muss. Somit ist der Nutzer bei Verwendung der 
Applikation in der Lage, aus einem vorab beliebigen Punkt zu starten und alle Objekte exakt auf die referenzierte, ursprüngliche Position zu setzen, die 
in der Scan-Phase festgelegt wurde. Nachdem die Position des aktuellen Objekts berechnet wurde, wird diese als neue „Pose“ initialisiert und übergeben, um 
das zu erstellende Objekt zu rendern und auf der Oberfläche anzuzeigen. Dabei findet eine Abfrage des Status statt, um daraufhin 
entscheiden zu können, in welcher Farbe das Objekt zu Präsentieren ist.  
\\ 
\begin{lstlisting}[language=C,
    frame=lines,           % Ein Rahmen um den Code (single for box, lines for top and bottom)
    xleftmargin=\parindent,  % Rahmen link von den Zahlen
    style=algoBericht,
    label={code:additionOfObject},
    captionpos=b,           % Caption unter den Code setzen
caption={Berechnung der Markerplatzierung}]
public void calculateObjectPosition
 (Object object, int i, Object objOrigin){
    ... 
    qx = object.getQx() + objOrigin.getQx();
    qy = object.getQy() + objOrigin.getQy();
    qw = object.getQw() + objOrigin.getQw();
    qz = object.getQz() + objOrigin.getQz();

    tx = object.getTx() + objOrigin.getTx();
    ty = object.getTy() + objOrigin.getTy();
    tz = object.getTz() + objOrigin.getTz();

    float[] rotation = {qx,qy,qz,qw};
    float[] translation = {tx,ty,tz};

    Pose pose = new Pose(translation, rotation);

    if(objectViewModel.getAllObjectsName()
     .getValue().get(i).getState() == 1) {
        addObject(Uri.parse("object.sfb"), pose, i);
    }

    if(objectViewModel.getAllObjectsName()
     .getValue().get(i).getState() == -1){
        addObject(Uri.parse("object_red.sfb"), pose, i);
    }
}
\end{lstlisting}
Sind alle Listenelemente abgearbeitet, ist die Erstellung und Renderung der Objekte fertig. Danach werden dem Nutzer alle vorhandenen Objekte angezeigt und 
visualisiert. Mit diesen Erkenntnissen kann der Nutzer durch den Raum laufen und alle Objekte überwachen. Wird ein Objekt anvisiert, kann über eine Berührung 
des Objekts auf dem Display alle vorhandenen Informationen eingesehen werden. Somit sind die Informationen des einzelnen Objekts schnell sichtbar.  
Die Applikation kann beliebig oft geschlossen und neu gestartet werden. Der Nutzer kann sich zu jeder Zeit die Objekte visualisieren lassen, vorausgesetzt, der 
Ursprungsmarker wird zu Anfang eingescannt. Daraufhin können alle Objekte präsentiert und die dazugehörigen Informationen angezeigt werden. %  zu jeder Zeit
\\ 
\linebreak
Um die soeben beschriebene Backend-Implementierung der Visualisierungs-Phase zu demonstrieren, wird diese anhand eines kleinen Szenarios veranschaulicht. 
\\ 
Startet der Nutzer die Visualisierungs-Phase, muss er den initialen Marker scannen, um fortfahren zu können. Darauffolgend öffnet sich die \acs{GUI} dieser 
Phase und mit einem Klick auf den Button rechts unten auf der Oberfläche synchronisiert er die Funktion und alle Objekte, die in der Scan-Phase gesetzt wurden, 
werden erneut generiert. Daraufhin kann der Nutzer die Objekte an den Stellen einsehen, an denen sie sich ursprünglich befanden. So werden diese samt Status 
angezeigt und der Nutzer hat den gesamten Überblick über alle Objekte und kann diese beobachten. Der Schritt ist der Abbildung (\ref{pic:visual_objects}) 
zu entnehmen. 
\begin{figure}[hbt!]
    \centering
    \includegraphics[width=7cm,height=7cm,keepaspectratio]{4Umsetzung/Bilder/show_objects_after_loading.jpg}
    \caption{Funktion Visualisierungs-Phase Teil 1}
    \label{pic:visual_objects}
\end{figure}
\pagebreak
\\
%\linebreak 
Eine weiter Funktion dieser Phase ist die Verwaltung der Objekte und deren Informationen. Wird ein Objekt anvisiert, werden mit einem Klick auf das Objekt 
die Informationen über ein PopUp angezeigt. Darunter ist der Namen des Objekts, der Status und die ID, die zu Anfang automatisch generiert 
und vergeben wurde. So kann zu jedem einzelnen Objekt dessen Informationen zur Verfügung gestellt werden. 
%\pagebreak
\begin{figure}[hbt!]
    \centering
    \subfigure[Anzeige der Objektinformationen 1]{\includegraphics[width=7cm,height=7cm,keepaspectratio]{4Umsetzung//Bilder/show_data_to_obj_1.jpg}}
    \subfigure[Anzeige der Objektinformationen 2]{\includegraphics[width=7cm,height=7cm,keepaspectratio]{4Umsetzung/Bilder/show_data_to_obj_2.jpg}}
    \subfigure[Anzeige der Objektinformationen 3]{\includegraphics[width=7cm,height=7cm,keepaspectratio]{4Umsetzung/Bilder/show_data_to_obj_3.jpg}}
    \caption{Funktion Visualisierungs-Phase Teil 2}
    \label{pic:showdatatoobj}
\end{figure}
\\
Um für den Prototypen eine möglichst realitätsnahe Anwendung zu simulieren, wurde mithilfe eines Threads eine Statusänderung der Objekte eingebaut. Dabei wird 
ein zufälliges Objekt selektiert und dessen Status-Informationen in der Datenbank geändert, bzw. aktualisiert. Über einen „Handler“ wird diese Aktion registriert 
und der Nutzer wird daraufhin benachrichtigt, indem auf dem Bildschirm eine Mitteilung aufkommt, in der die Änderungen und Informationen zu dem jeweiligen Objekt 
enthalten sind. Darauf kann der Nutzer im Nachgang reagieren, um die dementsprechende Entscheidung, was zu tun ist, zu treffen. Der folgende Ablaufplan stellt 
diese Funktion dar.
\begin{figure}[hbt!]
    \centering
    \includegraphics[width=10cm,height=9cm,keepaspectratio]{4Umsetzung/Bilder/changeInfoPAP.png}
    \caption{Programmablaufplan zur Informationsänderung eines zufälligen Objekts}
    \label{pic:startmenu}
\end{figure}
\\
Der „Thread“ läuft solange die Visualisierungs-Phase aktiv ist und wird erst mit schließen der Funktion beendet.
%\linebreak
%Nachdem die Aspekte der Front- und Backend-Entwicklung der drei Use Cases geschildert und Einblicke in die Entwicklung und die damit verbundenen Fragestellungen 
%und Schwierigkeiten gewährt wurden, geht es nun mit der Evaluierung des Systems, dem Fazit und dem Ausblick weiter.

%werden die implementierten Funktionen anhand eines Testdurchlaufs nochmals genauer 
%dargelegt.
%\section{Testdurchlauf} %/ Test-Szenario
%\label{chap:testdurchlauf}
%Ergänzend zur Implementierung wird in diesem Abschnitt das Resultat und die Anwendung der Applikation anhand eines unabhängigen Tests praktiziert, um die 
%Erzeugnisse der Entwicklung darzustellen und gegebenenfalls erweiternd zur eigentlichen Entwicklungsbeschreibung Ergebnisse zu präsentieren.